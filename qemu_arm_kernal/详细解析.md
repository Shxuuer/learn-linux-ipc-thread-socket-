# 对 qemu 启动自定义 kernel 和启动程序的详细解析

## 先从 kernel 开始

编译后的 kernel 会在`linux/arch/目标架构/boot`中包含 dtb、Image、Image.gz、vmlinux 等文件，dtb 代表了目标架构特定板子的硬件信息，Image 是编译后的 kernel 文件，Image.gz 是压缩后的 kernel 文件，vmlinux 是编译链接过程生成的原始内核文件。它是一个完整的 ELF 格式可执行文件，包含了所有内核代码和大量的调试信息。

dtb 在 kernel 启动前会被加载到内存中，kernel 启动后会解析 dtb 文件来获取硬件信息。其中包含的数据有哪个设备连接到哪个总线、设备的寄存器地址、中断号、时钟频率等信息。kernel 会根据这些信息来初始化和配置硬件设备驱动程序。

在 qemu 启动后，kernel 会被加载到内存的某个位置，通常是 0x80000（arm） 或 0x400000（aarch64），然后跳转到 kernel 的入口点开始执行。kernel 会进行一系列的初始化工作，包括设置内存管理、初始化中断处理程序、挂载根文件系统等。kernel 启动后会尝试挂载根文件系统。根文件系统可以是一个实际的存储设备（如硬盘、SD 卡等），也可以是一个内存中的临时文件系统（如 initramfs）。挂载根文件系统后，kernel 会启动第一个用户空间进程，通常是`/sbin/init`或`/init`，在 pc 的 linux 系统中，绝大多数的发行版都是/sbin/init，并且这个 init 文件指向 systemd，systemd 就是我们常用的进程管理守护进程。在该样例中，第一个用户空间进程是`/linuxrc`和`/mini_sh`，它们是我们自己编写的简单的初始化程序和 shell 程序。

## 再来看 rootfs

rootfs 是 root 文件系统的缩写，是 linux 系统中最顶层的文件系统。它包含了系统启动和运行所需的所有文件和目录，包括内核模块、设备文件、配置文件、用户程序等。rootfs 可以存储在不同类型的存储介质上，如硬盘、SD 卡、NAND 闪存等，也可以是一个内存中的临时文件系统（如 initramfs）。在该样例中，rootfs 会通过 initrd 传递给 qemu 的 ram，然后被 kernel 挂载为根文件系统。但在实际的嵌入式系统中，rootfs 通常存储在非易失性存储介质上，如 NAND 闪存、eMMC 等，pc 中通常存储在硬盘上。

打包 rootfs 这一过程分为以下几个任务：

1. 创建一个空的文件，作为根文件系统的存储介质。
2. 格式化该文件为 ext4 文件系统。
3. 将该文件挂载到一个目录，方便我们向其中添加文件和目录
4. 将所需的文件和目录复制到挂载目录中
5. 卸载该目录，完成根文件系统的打包

也就是说，我们创建了一个空的 ext4 文件，并把这个文件使用 loop 方式模拟挂载到一个目录，方便我们使用操作文件的方式对这个文件进行操作。

## busybox & 自己编写

其实，rootfs 的内容可以是任何东西，只要包含了 kernel 启动和运行所需的文件和目录即可。常见的做法是使用 busybox，它是一个集成了多种常用 linux 命令的工具箱，可以大大简化 rootfs 的构建过程。busybox 提供了一个简单的 init 程序，可以作为第一个用户空间进程启动系统，并且提供了常用的 shell 和其他命令，为了减小 rootfs 的体积，busybox 通常会被编译为一个静态链接的可执行文件，包含了所有依赖的库文件。

对于操作系统而言，其对第一个运行的进程有以下要求：

1. 必须是一个可执行文件，且具有执行权限
2. 不能够退出，否则 os 会进入 panic 状态
3. 必须能够初始化系统环境，如挂载必要的文件系统、设置环境变量等

## 关于 kernel、glibc 和静态编译

kernel 只负责管理硬件资源、提供系统调用接口等功能。常用的 malloc、printf 等函数并不是 kernel 提供的，而是由用户空间的 C 标准库（如 glibc、musl 等）提供的。glibc 封装了系统调用，提供了更高层次的接口，方便用户空间程序进行内存管理、字符串处理、文件操作等功能。而在我们的样例中，mini_init.c 和 mini_sh.c 这两个文件都依赖了 glibc 提供的函数，因此必须要使用静态编译，否则编译后的程序运行时会尝试动态加载 glibc 的共享库文件，而这些文件并不存在于 rootfs 中，导致程序无法运行。
